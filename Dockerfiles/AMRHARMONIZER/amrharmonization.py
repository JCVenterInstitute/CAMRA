# AMR Term Consensus 

# When hAMRonize outputs the consesus tsv, it does not consolidate the terms. 
# Example
#   ['aph(6)-Id','(AGly)strB','APH(6)-Id', 'APH6','aph(6)-Id','aph(6)-Id_1'] are AMR genes found by different combinations of tools and databases. 
#   There AMR also are in the same contig and the same location on the contig. Which terms should we use for analysis? 
#   The one most tools and databases agree with. The consensus term is APH(6)-Id. 

# This python script first looks at hAMRonize's output "hamronize_output.tsv". 
# First it groups all the terms that are found on the same contig at the same contig location. 
# It then normalizes the list (removes special characters and normalizes the case) leaving only the alphanumeric characters.
# This function uses the normalized terms to find the most common core among them and then formats it as needed

##########################################################################
## PACKAGES ##############################################################
##########################################################################

import pandas as pd
from collections import Counter
import sys

##########################################################################
## FUNCTIONS #############################################################
##########################################################################

#Cleaning Data
def clean_df(hamr_output):
    # 1 'input_sequence_id' contains the name of the contig where the AMR was found.
    #   Isolate all the rows that has an empty 'input_sequence_id' field
    #   These rows were generated by RESFINDER from reads.
    read_resfinder = hamr_output[hamr_output['input_sequence_id'].isna()]
    
    # 2 'input_sequence_id' contains the name of the contig where the AMR was found.
    #   Isolate all the rows that where 'analysis_software_name']=='resfinder' and 'input_sequence_id' is not empty
    #   These rows's 'input_sequence_id' are incorrectly formated. 
    #   eg "CCI165_S85_contig_8 length 181163 coverage 173.9 normalized_cov 0.95" becomes "CCI165_S85_contig_8"
    asm_resfinder = hamr_output[(hamr_output['analysis_software_name']=='resfinder') & (hamr_output['input_sequence_id'].notna())]
    asm_resfinder['input_sequence_id'] = asm_resfinder['input_sequence_id'].str.split().str[0]
    
    # All resfinder rows are removed from the dataframe  
    hamr_output = hamr_output[hamr_output['analysis_software_name']!='resfinder']
    
    # The modified resfinder rows from step 2 are added to the dataframe
    hamr_output = pd.concat([hamr_output,asm_resfinder])

    return hamr_output, read_resfinder

# Function to create an inverse dictionary
def inverse_dictionary(data):
    inversed_data = {}
    for key, values in data.items():
        for value in values:
            inversed_data[value[0]] = key
    return inversed_data

# Function to consesus terms based on optional cutoff values
def consesus_terms(data, contig, cutoff_from=None, cutoff_to=None):
    consesus_data = {}
    
    # If no cutoffs are provided
    if cutoff_from is None and cutoff_to is None:
        for key, values in data.items():
            value_collect = [value[0] for value in values]
            if value_collect:
                most_common_term = Counter(value_collect).most_common(1)[0][0]
                consesus_data[most_common_term] = values

    # If both cutoff_from and cutoff_to are provided
    elif cutoff_from is not None and cutoff_to is not None:
        for key, values in data.items():
            value_collect = [value[0] for value in values if cutoff_from <= value[3] <= cutoff_to]
            if value_collect:
                most_common_term = Counter(value_collect).most_common(1)[0][0]
                consesus_data[most_common_term] = values
    
    return consesus_data

# Function to consesus terms based on optional cutoff values
def consesus_terms(data, contig, cutoff_from=None, cutoff_to=None):
    consesus_data = {}
    
    # If no cutoffs are provided
    if cutoff_from is None and cutoff_to is None:
        for key, values in data.items():
            value_collect = [value[0] for value in values]
            if value_collect:
                most_common_term = Counter(value_collect).most_common(1)[0][0]
                consesus_data[most_common_term] = values

    # If both cutoff_from and cutoff_to are provided
    elif cutoff_from is not None and cutoff_to is not None:
        for key, values in data.items():
            value_collect = [value[0] for value in values if cutoff_from <= value[3] <= cutoff_to]
            if value_collect:
                most_common_term = Counter(value_collect).most_common(1)[0][0]
                consesus_data[most_common_term] = values
    
    return consesus_data

# Function to collect gene location information concisely
def concise_gene_location(data, row_collect, cutoff_from, cutoff_to):
    for key, value in data.items():
        count_in = 0
        count_all = len(value)
        
        score_all = [v[3] for v in value]
        score_in = [v[3] for v in value if cutoff_from <= v[3] <= cutoff_to]
        
        other_gene_symb_all = [v[0] for v in value]
        other_gene_symb_in = [v[0] for v in value if cutoff_from <= v[3] <= cutoff_to]

        avg_score_in = round(sum(score_in) / len(score_in),2) if score_in else None
        avg_score_all = round(sum(score_all) / len(score_all),2) if score_all else None

        count_in = len(score_in)
        
        row = [key, value[0][1], value[0][2], con, count_in, avg_score_in, other_gene_symb_in, count_all, avg_score_all, other_gene_symb_all]
        
        row_collect.append(row)
    
    return row_collect

# Assuming the `find_matches` function is defined as previously discussed
def find_matches(target, array):
    return [string for string in array if target[:4] in string]
    

# Custom function to find matches for a row's third column value
def find_matches_for_row(row):
    return find_matches(row[2], consesus_gene_symb)


##########################################################################
## MAIN ##################################################################
##########################################################################

# Import Data
file = sys.argv[1]
hamr_output = pd.read_table(file)
hamr_output, read_resfinder = clean_df(hamr_output)

# Collect unique contigs from data frame
contigs = hamr_output['input_sequence_id'].unique() 
genome_inversed_consesus_data_all = {}

# Arrays that collect the consensus terms
row_collect_98 = []
row_collect_all = []

#Iterate through the unique contigs
for con in contigs:
    # Filter DataFrame for the current contig
    con_df = hamr_output[hamr_output['input_sequence_id'] == con]

    # Create a new data frame containing these fields and collect the index values
    gene_data = con_df[['gene_symbol', 'input_gene_start', 'input_gene_stop', 'sequence_identity']].values
    gene_index = con_df.index.values

    # Collects hits at the same location of a contig.
    gene_collection = {}

    # Iterate though each row of the data frame, each row is an AMR hit
    for gene, idx in zip(gene_data, gene_index):
        # Assign variables 
        gene_sy, gene_sta, gene_sto, gene_id = gene
        # Set a start and stop range of the AMR hit. 
        range = 15
        start_1 = gene_sta - range
        start_2 = gene_sta + range
        stop_1 = gene_sta - range
        stop_2 = gene_sto + range

        # The current AMR hit is not mapped to any gene in gene_collection (dictionary)
        key_found = False

        # Iterate through the collection of genes (gene_collection) found in the con. 
        # Compare the AMR hit start and stop to the dictionary's various start and stop ranges. 
        for k in gene_collection.keys():
            if (gene_sta >= k[0] and gene_sta <= k[1] and 
                gene_sto >= k[2] and gene_sto <= k[3]):
                # If a the AMR hit in an equivalent position a a dictionary key, then add the hit to the value. 
                gene_collection[k].append([gene_sy, gene_sta, gene_sto, gene_id, idx,con])
                # The current AMR hit has been mapped a gene
                key_found = True
                break
        
        # If after iterating through the gene_collection and no mapping ocurred, then the AMR hit is added to the gene_collection (dictionary)
        if not key_found:
            gene_collection[(start_1, start_2, stop_1, stop_2)] = [[gene_sy, gene_sta, gene_sto, gene_id, idx,con]]
        
        # gene_collection OUTPUT: (1394, 1424, 2221, 2251): [['APH3-DPRIME', 1409, 2236, 99.88, 96, 'CCI86_S6_contig_33'], ["aph(3'')-Ib", 1409, 2236, 99.88, 134, 'CCI86_S6_contig_33']]}

    # Consolidate the terms, using all the list items. 
    contig_consesus_data_all = consesus_terms(gene_collection, con)
    # Consolidate the terms, only use the list items that have an identity score over or equal to 98
    contig_consesus_data_over98 = consesus_terms(gene_collection, con, cutoff_from= 98, cutoff_to=100)
    # OUTPUT: 'APH3-DPRIME': [['APH3-DPRIME', 1409, 2236, 99.88, 96, 'CCI86_S6_contig_33'], ["aph(3'')-Ib", 1409, 2236, 99.88, 134, 'CCI86_S6_contig_33']]

    # Make the AMR hit the key and the consolidated term the value
    contig_inversed_consesus_data_all = inverse_dictionary(contig_consesus_data_all)
    #OUTPUT {"aph(3'')-Ib": 'APH3-DPRIME', 'APH3-DPRIME': 'APH3-DPRIME'}

    # Arrays are populated with consensus terms
    row_collect_98 = concise_gene_location(contig_consesus_data_over98, row_collect_98, 98,100)
    row_collect_all = concise_gene_location(contig_consesus_data_all, row_collect_all, 98,100)
    
    # add the con's [AMR hit]:[consolidated term] from the  contig_inversed_consesus_data_all (dictionary) to the entire genome's genome_inversed_consesus_data_all (dictionary)
    genome_inversed_consesus_data_all |= contig_inversed_consesus_data_all

# Create data file of the consolidation term 
df_98 = pd.DataFrame(row_collect_98, columns=['consesus_gene_symbol', 'start', 'end', "contig", "#hits>=98", "average_identity (>=98)", "Other_gene_symbols (>=98)","#hits (all)", "average_identity (all)", "Other_gene_symbols (all)"])
df_all = pd.DataFrame(row_collect_all, columns=['consesus_gene_symbol', 'start', 'end', "contig", "#hits>=98", "average_identity (>=98)", "Other_gene_symbols (>=98)","#hits (all)", "average_identity (all)", "Other_gene_symbols (all)"])

# Add the consensus term as a column to the hamr_output and read_resfinder
hamr_output['consesus_gene_symbol'] = hamr_output['gene_symbol'].map(genome_inversed_consesus_data_all)
read_resfinder['consesus_gene_symbol'] = read_resfinder['gene_symbol'].map(genome_inversed_consesus_data_all)

# Add the earlier filtered resfinder read AMR hits back to the hamr_output
hamr_output = pd.concat([hamr_output,read_resfinder])


# Filter: Create a data frame containing all the AMR hits that did not map to a to a consensus term
hamr_IDisna = hamr_output[hamr_output['consesus_gene_symbol'].isna()]

# Make a list of all the consensus terms
consesus_gene_symb = df_all['consesus_gene_symbol'].tolist()

# Add a column to dataframe with possible consensus term 
# If resfinder with reads is not conducted then, the hamr_IDisna will be empty and throw an error. 
hamr_IDisna['possible_consesus_gene_symbol'] = hamr_IDisna.apply(find_matches_for_row, axis=1)

# Create CSV Files
hamr_IDisna.to_csv("hamronization_isna.tsv", sep='\t', index=False, mode='w')
hamr_output.to_csv("hamronization_all.tsv", sep='\t', index=False, mode='w')
df_98.to_csv("consesus_amr_over98identity.tsv", sep = '\t', index = False, mode='w')
df_all.to_csv("consesus_amr_allidentity.tsv", sep = '\t', index = False, mode='w')

##########################################################################
##########################################################################
##########################################################################

